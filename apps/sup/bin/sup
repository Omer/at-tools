#!/usr/bin/env ruby

require "uri"
require "net/http"
require "optparse"

def ask(question, default=nil, valid = /.*/, multiline=false)
  output = question
  output << " [#{default}]" unless default.nil?
  output << " (Optional)" if valid =~ ""
  output << ": "
  puts output
  
  matches = false
  answer = default

  while not matches
    if multiline
        answer = ""
      while not (input = gets).nil?
        answer << input
      end
      answer.chomp!
    else
      answer = gets.chomp
    end

    matches = answer =~ valid
    
    if answer.empty? and default 
      answer = default
      matches = true
    end
   
    unless matches
      puts "The entered input is invalid. Please try again: "
    end 
  end 

  answer
end

# Set up the usage options.

options = {
  :user => ENV['LOGNAME'] || ENV['USERNAME'] || ENV['USER'],
  :machine => ENV['SHORT_HOSTNAME'],
  :email => nil,
  :urgent => 0
}

optparse = OptionParser.new do |opts|
  opts.banner = "Usage: sup [OPTIONS] [TITLE] [MESSAGE]"
  opts.program_name = "sup"
  opts.version = "0.0.1"
  
  opts.on("-h", "--help", "Display this screen.") do
    puts opts
    exit
  end

  opts.separator ""
  opts.separator "General"

  opts.on("-u", "--user=USERNAME",
          "The username to use when sending the report. Defaults to the current username.") do |user|
    options[:user] = user
  end

  opts.on("-m", "--machine=MACHINE", "The machine which you are reporting a problem with.") do |machine|
    options[:machine] = machine
  end

  opts.separator ""
  opts.separator "Additional"

  opts.on("-e", "--email=EMAIL", "An alternative email address for the support request.") do |email|
    options[:email] = email
  end

  opts.on("-s", "--serious", "Marks the request as urgently requiring attention.") do
    options[:urgent] = 1
  end
end

begin
  optparse.parse!
rescue OptionParser::InvalidOption
  puts optparse.help
  exit 0
end
# 
# Try and get the current username if the user didnt enter one.
#
# May want to check with a regexp to make sure its a valid dice name?
# (As in, if user on non-dice computer.)
options[:user] = ask("Username", options[:user], /s\d+/)
options[:machine] = ask("Machine Name", options[:machine], /.+/)
options[:email] = options[:email] || ask("Email", nil, /.*/)
options[:urgent] = ask("Urgent?", options[:urgent], /(1|0)/)

subject = ARGV.shift || ask("Subject", nil, /.+/)
description = ARGV.shift || ask("Message", nil, /.+/, true)

# Fire off the request. Currently uses a test php file located on my
# (Stephen McGruer) website which merely echos the POST values.
#
# We need to find out how to test that we're addressing the "urgent"
# keyword properly without spamming CS. Maybe ask them what they try and
# match?
#
# Will also need to guard against 404, 403, no connection, etc.
params = {
  :username => options[:user],
  :machine_name => options[:machine],
  :email => options[:email],
  :short_message => subject,
  :urgent => options[:urgent],
  :long_message => description
}

response = Net::HTTP.post_form(URI.parse("http://www.tardis.ed.ac.uk/~ediblespread/rubytest/test.php"), params)

puts response.body
